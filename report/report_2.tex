\documentclass[a4paper,10pt]{article}
\usepackage{fullpage, amsfonts, amsmath, indentfirst, graphicx, natbib}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\bibliographystyle{apalike}


\begin{document}
\begin{center}
Project report on\\
\vspace{0.5cm}
{{\Large \sc Belief Revision}} \\
\vspace{0.5cm} for 02180 Introduction to Artificial Intelligence
\end{center}
\rule{\textwidth}{0.5pt}
\begin{description}
\item\begin{tabular}{rll}
    \textbf{Contributors:}  & Jannis Haberhausen  & (s186398) \\
                            & Jack Reinhardt      & (s186182) \\
                            & Kilian Speiser      & (s181993) \\
                            & Jacob Miller        & (s186093) \\
\end{tabular}
\end{description}
\rule{\textwidth}{1pt}

\tableofcontents
\newpage

\section{Introduction}
\label{sec:intro}


\section{Design and Implementation}
\label{sec:design}
The design of the belief base takes advantage of the object-oriented nature of the Python programming language. At the highest level, the contents of the
belief base are stored in an instance of a class called BeliefBase. The BeliefBase class simply contains a list of beliefs along with methods for adding
or removing beliefs, checking for logical entailment, performing partial meet contraction, and showing the current belief base. One level lower, the beliefs
are represented as an instance of the class Belief. Each belief contains a list of clauses, which is initialized when the object is created, taking an input
string in CNF with an option for negating the entire belief. The Belief class also contains methods to print the belief or to convert the belief to a string.
At the lowest level is the Clause class, which stores a list of the positive propositional symbols and a list of the negative propositional symbols. These two
lists are initialized when each Clause is created by parsing the string that is input. The methods in Clause include deleting symbols, checking if the clause
is empty and printing or converting the clause to a string. The Clause class also implements static methods to combine clauses, create a copy of a clause,
check if two clauses are equal, negate a clause, and resolve two clauses.

\subsection{Implementation - Converting to CNF}
\label{subsec:implementation_cnf}

\subsection{Implementation - Converting CNF into Beliefs and Clauses}
\label{subsec:implementation}
Once the input string is converted into CNF, the string is converted into a list of clauses, which is stored in a belief. Each AND ('$\wedge$') symbol marks the end of
a clause when in CNF; any spaces, double negations, and parenthesis are removed from the string before it is used to initialize a new clause object. The
initialization of each clause then removes all OR ('$\vee$') symbols and adds each propositional symbol to either the positive symbol list or the negative symbol list
(symbols that are negated).

\subsection{Assumptions}
\label{subsec:assumptions}
The design and implementation of the belief base makes one important assumption: that each propositional logic symbol is a single character. This was a
design choice for robustly implementing the parsing of string and converting the strings into beliefs and clauses.

\section{Logical Entailment}
\label{sec:entail}
A resolution-based approach was used to check for logical entailment in the belief base. Once a belief base has been initialized and beliefs have been added
to it, logical entailment can be checked of an input belief in string form. First, the input string is converted into its negation as a belief object as described
in section \ref{subsec:negation}. Then, all of the clauses in the belief base and the clauses of the input belief are stored in a single list to iterate over. The
resolution algorithm loops over pairs of clauses, resolves these clauses, and then checks if the resolvent is either empty or already in the list of clauses.
The implementation of the resolution algorithms is further explained in section \ref{subsec:resolution}. If two clauses resolve to an empty clause,
then the method returns true, indicating that the input belief is entailed by the belief base. Otherwise, if the list of clauses has been exhausted and no further
clauses can be added through resolution, then the loop terminates and the method returns false, indicating that the input belief is not entailed by the belief
base. \\

A list containing all pairs of clauses that have already been resolved was added to improve the efficiency of the resolution algorithm. Each time the algorithm
iterates over a pair of clauses, it checks that the clauses are not equal (not the same clause) and that the pair of clauses is not in the list of previously
resolved clauses. \\

\subsection{Resolution}
\label{subsec:resolution}
A static method was implemented to resolve two disjunctive clauses in the Clause class. The algorithm first searches for and removes any complementary literals
in the two clauses. Next, it searches for and removes any redundant symbols (i.e. 'avbvb' would simplify to 'avb'). Finally, the two clauses are combined into
a single disjunctive clause and returned as the resolvent.

\subsection{Belief Negation}
\label{subsec:negation}
When checking whether or not a belief is entailed by the belief base, resolution essentially performs a proof by contradiction, which requires negating the input belief.
To negate the belief, it is first broken up into individual clauses. Each clauses is then negated through the use of De Morgans Law. Distributing $\vee$ over $\wedge$
then yields the negated belief in CNF, which can be used to check for logical entailment with resolution.

\section{Revision}
\label{sec:revision}


\subsection{Partial Meet Contraction}
\label{subsec:contraction}


\section{What We've Learned}
\label{sec:learned}


\section{Conclusion and Future Work}
\label{sec:conclusion}


\bibliography{bib/bib}

\end{document}
